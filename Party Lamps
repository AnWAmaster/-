原题链接：
https://vjudge.net/contest/441568#problem/O

题目大意：
给出N盏灯，每盏灯有0（关灯），1（开灯）两种状态

给出4个按钮，按下每个按钮产生的效果如下

1、全部灯互异
2、奇数灯互异
3、偶数灯互异
4、编号为3*K+1的灯互异

给出按下按钮的次数CNT
给出最终情况下的部分开的灯的下标和部分关的灯的下标，输入以-1结束（强烈注意是“部分”，即<=实际情况）

要求最终可能出现的所有灯的情况（以字典序二进制表示）

题目分析：
首先要想清几件事：
1、同一个按钮按两次等于没按
2、灯的情况每六个每六个都是一样的，
即lamp[i]=lamp[i%6](i不是6的倍数)  
  lamp[i]=lamp[6](i是6的倍数)
   （上面的分情况是因为6个为一个循环，但是6k%6=0,而我们需要的是第6个）
3、按下按钮次数CNT>4时可以实现所有可能的按法，而c<=4则通过深搜来进行枚举。
这一条我是看博客知道的，有枚举的，有推出来的，他是这么描述的
________________________________________________________________________________________________
①易得任意一个按钮按下2次，等于该按钮按下0次
打表后观察得：②1，2，3这个3个按钮任意两个按下等同于第三个按下
由①得：任意偶数次按按钮均可以转化为0，2，4次按不同按钮，任意奇数次按按钮均可以转化为1，3次按不同按钮
由②得：所按按钮均不同时，相邻次数可以转化，即(1,2),(2,3),(3,4)这三种按不同按钮次数的组合内可以相互转化
综上：当按按钮次数大于等于3时，所有灯的状态均可能出现
————————————————
版权声明：本文为CSDN博主「满赋诸机」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/idealism_xxm/article/details/50594553
_________________________________________________________________________________________________
4、既然灯的情况只有0和1，我们就可以用整型数据表示每种情况
   而我们只需要得到前六个灯的情况即可，2^6-1即0~63就可以表示前六个灯的所有情况
   即可用bool book[64]即可实现查重
5、互异、取反操作实现灯状态的改变

以上就是做这道题的一些需要知道的东西
其实知道这些就差不多能AC了，剩下的就是要具体的dfs去搜索符合题给最终状态情况的灯的情况、判断两情况是否相同的操作、
互异操作的细节了

AC代码
#include<iostream>
#include<cmath>
using namespace std;

int N,CNT,v[7],lamp=63;//111111
bool book[64];
//lamp记录六盏灯的情况，v数组记录题目要求，book用来去重

void check(){//判断是否符合要求
    int i,temp=0;
    int t=(int)pow(2,6);//100000
    for(i=1;i<=6;i++){
    	t>>=1;
    	//判断与题给要求是否一致 
        if(v[i]==0&&(lamp&t))return; 
        if(v[i]==1&&!(lamp&t))return;
        temp+=lamp&t;
    }
    if(book[temp])return;//如果情况已出现过则return
    book[temp]=true;
    return ;
}
void dfs(int step){
    if(step>CNT)
	{
    	check();
		return;
    }
    for(int i=1;i<=4;i++){
    	if(i==1){
    		lamp=~lamp;
		}else if(i==2){
			lamp=lamp^42;//101010 
		}else if(i==3){
			lamp=lamp^21;//010101
		}
		else if(i==4){
			lamp=lamp^36;//100100
		}
		dfs(step+1);
		//复原 
		if(i==1){
			lamp=~lamp;
		}else if(i==2){
			lamp=lamp^42;
		}
		else if(i==3){
			lamp=lamp^21;
		}
		else if(i==4){
			lamp=lamp^36;
		}
	}
}
int main()
{
    cin>>N>>CNT;
    if(CNT>4)CNT=4;
    int i,j,temp;
    for(i=0;i<7;i++)v[i]=-1;
    while(cin>>temp&&temp!=-1){//记录亮的灯
    	temp%=6;
    	if(!temp)temp=6;
        v[temp]=1;
    }
    while(cin>>temp&&temp!=-1){//记录关的灯
        temp%=6;
    	if(!temp)temp=6;
        v[temp]=0;
    }
    dfs(1);
    int a[8];
    //遍历前6个灯的所有情况 
    for(j=0;j<64;j++)
	{
        if(book[j])
		{
            //把前六位提出来，方便后面的使用 
			for(int i=5,k=1;i>=0;i--,k++){
            	a[k]=(j>>i)&1;
			}
			for(int i=1;i<=N;i++){
				int k=i%6;//超过了六位的位都与前六位相同 
				if(!k)k=6;
				cout<<a[k];
			}
			cout<<endl;
        }
    } 
    return 0;
}






